name: Docker Image CI - Build Dev

on:
  push:
    branches:
      - devrelease/*
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract branch name
        shell: bash
        run: echo "BR_VERSION=${GITHUB_REF##*/}" >> "$GITHUB_OUTPUT"
        id: extract_branch

      #      - name: Uncomment image line in config.yaml if commented
      #        shell: bash
      #        run: |
      #          CONFIG_FILE="./${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml"
      #          echo "Checking and uncommenting image line in $CONFIG_FILE"
      #          # Use sed to remove '# ' prefix from the line starting with '# image:'
      #          sed -i 's/^#\s*image:/image:/' "$CONFIG_FILE"
      #          echo "Finished uncommenting check."

      - name: üëì read-yaml-file ${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
        uses: pietrobolcato/action-read-yaml@1.1.0
        id: read_action_js
        with:
          config: ${{ github.workspace }}/${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
          # This action reads all top-level keys, so 'name' and 'version' will be available
          # as steps.read_action_js.outputs.name and steps.read_action_js.outputs.version

      - name: Prepare Version and Name for YAML
        id: prepare_yaml_values
        shell: bash
        run: |
          CURRENT_VERSION_FROM_FILE="${{ steps.read_action_js.outputs.version }}"
          CURRENT_NAME_FROM_FILE="${{ steps.read_action_js.outputs.name }}"

          FINAL_VERSION_BASE="$CURRENT_VERSION_FROM_FILE"
          FINAL_NAME="$CURRENT_NAME_FROM_FILE"

          # Check for .alpha<N> suffix on version
          if [[ "$CURRENT_VERSION_FROM_FILE" =~ ^(.*)-alpha([0-9]+)$ ]]; then
            FINAL_VERSION_BASE="${BASH_REMATCH[1]}" # Remove -alpha<N> from version
            if [[ ! "$CURRENT_NAME_FROM_FILE" =~ \-‚ç∫$ ]]; then
              FINAL_NAME="${CURRENT_NAME_FROM_FILE}-‚ç∫" # Add -‚ç∫ to name
            fi
          # Check for .beta<N> suffix on version
          elif [[ "$CURRENT_VERSION_FROM_FILE" =~ ^(.*)-beta([0-9]+)$ ]]; then
            FINAL_VERSION_BASE="${BASH_REMATCH[1]}" # Remove -beta<N> from version
            if [[ ! "$CURRENT_NAME_FROM_FILE" =~ \-Œ≤$ ]]; then
              FINAL_NAME="${CURRENT_NAME_FROM_FILE}-Œ≤" # Add -Œ≤ to name
            fi
          # Check for .dev<N> suffix on version
          elif [[ "$CURRENT_VERSION_FROM_FILE" =~ ^(.*)-dev([0-9]*)$ ]]; then
            FINAL_VERSION_BASE="${BASH_REMATCH[1]}" # Remove -dev<N> from version
          fi

          # Append -dev<run_number> to the (potentially modified) base version
          FINAL_VERSION_TO_SET="${FINAL_VERSION_BASE}-dev${{ github.run_number }}"

          echo "FINAL_VERSION_TO_SET=${FINAL_VERSION_TO_SET}" >> "$GITHUB_OUTPUT"
          echo "FINAL_NAME_TO_SET=${FINAL_NAME}" >> "$GITHUB_OUTPUT"
          echo "EXTRACTED_BASE_VERSION=${FINAL_VERSION_BASE}" >> "$GITHUB_OUTPUT" # Output the base version

      - name: ‚úçüèº Set version in ${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
        id: version_set # This ID is used by subsequent steps for value_old
        uses: endaft/action-yamler@v1.1.1
        with:
          file: ./${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
          path: version
          set: ${{ steps.prepare_yaml_values.outputs.FINAL_VERSION_TO_SET }}
          get: true # Captures the version value before this 'set' operation

      - name: ‚úçüèº Set name in ${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
        uses: endaft/action-yamler@v1.1.1
        with:
          file: ./${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
          path: name
          set: ${{ steps.prepare_yaml_values.outputs.FINAL_NAME_TO_SET }}

      - name: Publish ${{ steps.extract_branch.outputs.BR_VERSION }} Addon  ${{ steps.prepare_yaml_values.outputs.FINAL_VERSION_TO_SET }}
        uses: home-assistant/builder@2025.03.0
        env:
          CAS_API_KEY: ${{ secrets.CAS_API_KEY }}
        with:
          args: |
            --aarch64 \
            --target ${{ steps.extract_branch.outputs.BR_VERSION }} \
            --no-latest \
            --docker-hub dianlight ${{ steps.read_action_js.outputs.image == '' && format('--test --image dianlight/aarch64-addon-{0}', steps.extract_branch.outputs.BR_VERSION) || '' }}

      - name: pull-request
        if: ${{ steps.read_action_js.outputs.image != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
        continue-on-error: true
        shell: bash
        run: |
          set -x
          
          git config --global user.email "workflow-bot@github.com"
          git config --global user.name "Prerelease Bot"

          ADDON_DIR="${{ steps.extract_branch.outputs.BR_VERSION }}"
          BASE_VERSION="${{ steps.prepare_yaml_values.outputs.EXTRACTED_BASE_VERSION }}"
          # PR_BASE_BRANCH_NAME is the target branch for script commits and the PR base
          PR_BASE_BRANCH_NAME="prerelease/${ADDON_DIR}_${BASE_VERSION}"
          # PR_HEAD_BRANCH_NAME is the source branch for the PR (e.g., devrelease/myaddon)
          PR_HEAD_BRANCH_NAME="${BRANCH_NAME}" # Using the env var already defined for the step
          # Note: SCRIPTS_DIR_FROM_ROOT would be "./${ADDON_DIR}/scripts"

          echo "Fetching origin master and head branch ${PR_HEAD_BRANCH_NAME}"
          git fetch origin master "${PR_HEAD_BRANCH_NAME}"

          echo "Creating/resetting local branch '${PR_BASE_BRANCH_NAME}' from 'origin/master'"
          git branch -f "${PR_BASE_BRANCH_NAME}" "origin/master"

          echo "Checking out branch '${PR_BASE_BRANCH_NAME}' to run scripts"
          git checkout "${PR_BASE_BRANCH_NAME}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to checkout branch ${PR_BASE_BRANCH_NAME}."
            exit 1 # This will be caught by continue-on-error for the step
          fi

          # Run scripts if the directory exists
          if [ -d "$SCRIPTS_DIR" ]; then
            echo "Scripts directory '$SCRIPTS_DIR' found. Executing scripts..."
            # Robustly iterate over script files
            find "$SCRIPTS_DIR" -type f -print0 | while IFS= read -r -d $'\0' SCRIPT_FILE; do
              echo "Executing script: $SCRIPT_FILE"
              # Attempt to execute directly if permissions allow, otherwise use bash as a fallback.
              # Ensure scripts have a shebang (e.g., #!/bin/bash, #!/usr/bin/env python3) if they are not bash scripts but are marked executable.
              if [ -x "$SCRIPT_FILE" ]; then
                  "$SCRIPT_FILE"
              else
                  bash "$SCRIPT_FILE"
              fi
              
              SCRIPT_EXIT_CODE=$?
              if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                  echo "Warning: Script $SCRIPT_FILE finished with exit code $SCRIPT_EXIT_CODE."
                  # Continue to the next script even if one fails
              fi
            done

            echo "Checking for changes after script execution on branch '${PR_BASE_BRANCH_NAME}'..."
            git add . # Stage all changes made by scripts
            if [ -n "$(git status --porcelain)" ]; then
              echo "Committing script-generated changes to '${PR_BASE_BRANCH_NAME}'"
              git commit -m "auto: Run scripts in $SCRIPTS_DIR for $ADDON_DIR"
              if [ $? -ne 0 ]; then
                echo "Warning: Failed to commit script-generated changes."
              fi
            else
              echo "No changes to commit after script execution."
            fi
          else
            echo "Scripts directory '$SCRIPTS_DIR' not found. Skipping script execution."
          fi

          echo "Pushing branch '${PR_BASE_BRANCH_NAME}' to origin (with force)"
          git push -f origin "${PR_BASE_BRANCH_NAME}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to push branch ${PR_BASE_BRANCH_NAME}."
            exit 1 # Caught by continue-on-error
          fi

          echo "Switching back to branch '${PR_HEAD_BRANCH_NAME}'"
          git checkout "${PR_HEAD_BRANCH_NAME}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to checkout back to branch ${PR_HEAD_BRANCH_NAME}."
            exit 1 # Caught by continue-on-error
          fi

          echo "Creating PR from '${PR_HEAD_BRANCH_NAME}' to '${PR_BASE_BRANCH_NAME}'"
          gh pr create \
            --base "${PR_BASE_BRANCH_NAME}" \
            --head "${PR_HEAD_BRANCH_NAME}" \
            --title "Releasing ${PR_HEAD_BRANCH_NAME} into ${PR_BASE_BRANCH_NAME}" \
            --fill || :
