name: Docker Image CI - Build Dev

on:
  push:
    branches:
      - devrelease/*
  workflow_dispatch: # Allows manual triggering of the workflow

permissions:
  pull-requests: write # Required for creating pull requests
  contents: write # Required for committing changes and pushing to the repository
  packages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest # Specifies the runner environment

    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          submodules: true # Also checks out git submodules if any

      - name: Login to DockerHub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract branch name
        id: extract_branch # Assigns an ID to this step to reference its outputs
        shell: bash
        run: echo "BR_VERSION=${GITHUB_REF##*/}" >> "$GITHUB_OUTPUT"
        # Extracts the branch name (e.g., 'myaddon' from 'devrelease/myaddon')
        # and sets it as a step output named BR_VERSION.

      - name: üëì Read config.yaml
        uses: pietrobolcato/action-read-yaml@9f13718d61111b69f30ab4ac683e67a56d254e1d # 1.1.0 # Reads values from a YAML file
        id: read_action_js # Assigns an ID to reference its outputs
        with:
          config: ${{ github.workspace }}/${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml
          # Reads 'name' and 'version' (and potentially 'image') from the config.yaml
          # These will be available as steps.read_action_js.outputs.name, .version, .image

      - name: Prepare Version, Name, and Image for YAML
        id: prepare_yaml_values # Assigns an ID to reference its outputs
        shell: bash
        run: |
          CURRENT_VERSION_FROM_FILE="${{ steps.read_action_js.outputs.version }}"
          CURRENT_NAME_FROM_FILE="${{ steps.read_action_js.outputs.name }}"
          # Get the current image from config.yaml, or an empty string if not found/commented
          CURRENT_IMAGE_FROM_FILE="${{ steps.read_action_js.outputs.image }}"

          FINAL_VERSION_BASE="$CURRENT_VERSION_FROM_FILE"
          FINAL_NAME="$CURRENT_NAME_FROM_FILE"
          FINAL_IMAGE_TO_SET="$CURRENT_IMAGE_FROM_FILE"
          
          if [[ "$FINAL_NAME" =~ ^(.*)-[Œ≤‚ç∫]$ ]]; then
            FINAL_NAME=${BASH_REMATCH[1]}
          fi

          # Check for .alpha.<N> suffix on version and adjust name/version base
          if [[ "$CURRENT_VERSION_FROM_FILE" =~ ^(.*)-alpha(\.([0-9]+))?$ ]]; then
            FINAL_VERSION_BASE="${BASH_REMATCH[1]}" # Remove -alpha.<N> from version
            if [[ ! "$CURRENT_NAME_FROM_FILE" =~ \-‚ç∫$ ]]; then
              FINAL_NAME="${FINAL_NAME}-‚ç∫" # Add -‚ç∫ to name
            fi
          # Check for .beta.<N> suffix on version and adjust name/version base
          elif [[ "$CURRENT_VERSION_FROM_FILE" =~ ^(.*)-beta(\.([0-9]+))?$ ]]; then
            FINAL_VERSION_BASE="${BASH_REMATCH[1]}" # Remove -beta.<N> from version
            if [[ ! "$CURRENT_NAME_FROM_FILE" =~ \-Œ≤$ ]]; then
              FINAL_NAME="${FINAL_NAME}-Œ≤" # Add -Œ≤ to name
            fi
          # Check for .dev.<N> suffix on version (already handled by builder suffix)
          elif [[ "$CURRENT_VERSION_FROM_FILE" =~ ^(.*)-dev(\.([0-9]*))?$ ]]; then
            FINAL_VERSION_BASE="${BASH_REMATCH[1]}" # Remove -dev.<N> from version
          fi
          
          echo "FINAL_NAME_TO_SET=${FINAL_NAME}" >> "$GITHUB_OUTPUT"
          echo "FINAL_IMAGE_TO_SET=${FINAL_IMAGE_TO_SET}" >> "$GITHUB_OUTPUT"
          echo "EXTRACTED_BASE_VERSION=${FINAL_VERSION_BASE}" >> "$GITHUB_OUTPUT" # Output the base version

          #Debugging output to verify values
          echo "Final name to set: $FINAL_NAME"
          echo "Final image to set: $FINAL_IMAGE_TO_SET"
          echo "Extracted base version: $FINAL_VERSION_BASE"
          

      - name: ‚úçüèº Set version in config.yaml
        id: version_set # This ID is used by subsequent steps for value_old
        shell: bash
        run: |
          CONFIG_FILE="./${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml"
          NEW_VERSION="${{ steps.prepare_yaml_values.outputs.EXTRACTED_BASE_VERSION }}"
          
          # Get current value before modification
          OLD_VERSION=$(yq '.version' "$CONFIG_FILE")
          echo "value_old=$OLD_VERSION" >> "$GITHUB_OUTPUT"
          
          # Set new version
          yq -i ".version = \"$NEW_VERSION\"" "$CONFIG_FILE"
          
          # Get new value after modification
          NEW_VALUE=$(yq '.version' "$CONFIG_FILE")
          echo "value_new=$NEW_VALUE" >> "$GITHUB_OUTPUT"
          
          echo "Updated version from '$OLD_VERSION' to '$NEW_VALUE'"

      - name: ‚úçüèº Set name in config.yaml
        shell: bash
        run: |
          CONFIG_FILE="./${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml"
          NEW_NAME="${{ steps.prepare_yaml_values.outputs.FINAL_NAME_TO_SET }}"
          
          # Get current value before modification
          OLD_NAME=$(yq '.name' "$CONFIG_FILE")
          
          # Set new name
          yq -i ".name = \"$NEW_NAME\"" "$CONFIG_FILE"
          
          echo "Updated name from '$OLD_NAME' to '$NEW_NAME'"

      - name: ‚úçüèº Set image in config.yaml
        shell: bash
        run: |
          CONFIG_FILE="./${{ steps.extract_branch.outputs.BR_VERSION }}/config.yaml"
          NEW_IMAGE="${{ steps.prepare_yaml_values.outputs.FINAL_IMAGE_TO_SET }}"
          
          # Get current value before modification
          OLD_IMAGE=$(yq '.image' "$CONFIG_FILE")
          
          # Set new image
          yq -i ".image = \"$NEW_IMAGE\"" "$CONFIG_FILE"
          
          echo "Updated image from '$OLD_IMAGE' to '$NEW_IMAGE'"
          # The image field will be set to the DockerHub repository (e.g., dianlight/myaddon-alpha)
          # The 'home-assistant/builder' will then tag this image with the 'version' from config.yaml.

      - name: Run Addon custom scripts
        # Only run this step if the scripts directory exists for the current addon
        if: ${{ hashFiles(format('{0}/{1}/scripts', github.workspace, steps.extract_branch.outputs.BR_VERSION)) != '' }}
        env:
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }} # The current branch name (e.g., devrelease/myaddon)
        shell: bash
        run: |
          set -x # Enable verbose output for debugging

          ADDON_DIR="${{ steps.extract_branch.outputs.BR_VERSION }}"
          SCRIPTS_DIR="${{ github.workspace }}/${ADDON_DIR}/scripts"

          # Run scripts if the directory exists (already checked by 'if' condition)
          echo "Scripts directory '$SCRIPTS_DIR' found. Executing scripts..."
          find "$SCRIPTS_DIR" -type f -print0 | while IFS= read -r -d $'\0' SCRIPT_FILE; do
            echo "Executing script: $SCRIPT_FILE"
            if [ -x "$SCRIPT_FILE" ]; then
              "$SCRIPT_FILE"
            else
              bash "$SCRIPT_FILE"
            fi
            
            SCRIPT_EXIT_CODE=$?
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
              echo "Warning: Script $SCRIPT_FILE finished with exit code $SCRIPT_EXIT_CODE."
              # Continue to the next script even if one fails
            fi
          done

      - name: Publish Home Assistant Addon ${{ steps.extract_branch.outputs.BR_VERSION }}
        uses: home-assistant/builder@master #71885366c80f6ead6ae8c364b61d910e0dc5addc # 2025.03.0 # Home Assistant Add-on builder action
        env:
          CAS_API_KEY: ${{ secrets.CAS_API_KEY }} # API key for artifact signing (if used by the builder)
        with:
          args: |
            --amd64 --aarch64 \
            --version ${{ steps.prepare_yaml_values.outputs.EXTRACTED_BASE_VERSION }}-dev.${{ github.run_number }} \
            --target ${{ steps.extract_branch.outputs.BR_VERSION }} \
            --no-latest \
            --docker-hub dianlight

      - name: Create Merge Release Branch
        # Only run this step if the scripts directory exists for the current addon
        if: ${{ hashFiles(format('{0}/{1}/scripts', github.workspace, steps.extract_branch.outputs.BR_VERSION)) != '' }}
        env:
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }} # The current branch name (e.g., devrelease/myaddon)
        shell: bash
        run: |
          set -x # Enable verbose output for debugging

          git config --global user.email "workflow-bot@github.com"
          git config --global user.name "Prerelease Bot" # Using the same bot name for consistency

          ADDON_DIR="${{ steps.extract_branch.outputs.BR_VERSION }}"
          SCRIPTS_DIR="${{ github.workspace }}/${ADDON_DIR}/scripts"
          MERGE_RELEASE_BRANCH="mergerelease/${ADDON_DIR}" # New branch name: mergerelease/<addon>

          echo "Add all changes to git staging area"
          git add .

          echo "Committing changes"
          git commit -m "ci(script) Commit all automatic changes for mergerelease in $ADDON_DIR" || true

          echo "Checking out branch '${MERGE_RELEASE_BRANCH}'"
          git checkout -b "${MERGE_RELEASE_BRANCH}"

          echo "Pushing branch '${MERGE_RELEASE_BRANCH}' to origin (with force)"
          git push -f origin "${MERGE_RELEASE_BRANCH}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to push branch ${MERGE_RELEASE_BRANCH}."
            exit 1
          fi

      - name: Create Pull Request
        # This step runs if the 'image' field was initially NOT empty,
        # indicating it's a "real" addon for which a PR is desired.
        if: ${{ steps.read_action_js.outputs.image != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GitHub token for authentication with 'gh' CLI
          CURRENT_WORKFLOW_BRANCH: ${{ github.head_ref || github.ref_name }} # The current branch name (e.g., devrelease/myaddon)
        continue-on-error: true # Allows the workflow to continue even if this step fails
        shell: bash
        run: |
          set -x # Enable verbose output for debugging

          git config --global user.email "workflow-bot@github.com"
          git config --global user.name "Prerelease Bot"

          ADDON_DIR="${{ steps.extract_branch.outputs.BR_VERSION }}"
          BASE_VERSION="${{ steps.prepare_yaml_values.outputs.EXTRACTED_BASE_VERSION }}"
          # PR_BASE_BRANCH_NAME is the target branch for script commits and the PR base (e.g., prerelease/myaddon_1.0.0)
          PR_BASE_BRANCH_NAME="prerelease/${ADDON_DIR}_${BASE_VERSION}"

          # Determine PR_HEAD_BRANCH_NAME: prefer mergerelease/* if it exists, else use devrelease/*
          MERGE_RELEASE_CHECK_BRANCH="mergerelease/${ADDON_DIR}"
          PR_HEAD_BRANCH_NAME="${{ env.CURRENT_WORKFLOW_BRANCH }}" # Default to the current workflow branch

          echo "Checking if merge release branch '${MERGE_RELEASE_CHECK_BRANCH}' exists..."
          # Fetch the remote branch list and check for the merge release branch
          if git ls-remote --exit-code origin "${MERGE_RELEASE_CHECK_BRANCH}" &>/dev/null; then
            echo "Merge release branch '${MERGE_RELEASE_CHECK_BRANCH}' exists. Using it as PR head."
            PR_HEAD_BRANCH_NAME="${MERGE_RELEASE_CHECK_BRANCH}"
          else
            echo "Merge release branch '${MERGE_RELEASE_CHECK_BRANCH}' does not exist. Using current workflow branch as PR head."
            # PR_HEAD_BRANCH_NAME already defaults to CURRENT_WORKFLOW_BRANCH
          fi

          echo "Fetching origin master and head branch ${PR_HEAD_BRANCH_NAME}"
          git fetch origin master "${PR_HEAD_BRANCH_NAME}"

          echo "Creating/resetting local branch '${PR_BASE_BRANCH_NAME}' from 'origin/master'"
          git branch -f "${PR_BASE_BRANCH_NAME}" "origin/master"

          echo "Checking out branch '${PR_BASE_BRANCH_NAME}'"
          git stash -u # Stash untracked files as well, to avoid conflicts
          git checkout "${PR_BASE_BRANCH_NAME}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to checkout branch ${PR_BASE_BRANCH_NAME}."
            exit 1
          fi

          echo "Pushing branch '${PR_BASE_BRANCH_NAME}' to origin (with force)"
          git push -f origin "${PR_BASE_BRANCH_NAME}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to push branch ${PR_BASE_BRANCH_NAME}."
            exit 1
          fi

          echo "Switching back to the determined head branch '${PR_HEAD_BRANCH_NAME}' for PR creation"
          git checkout "${PR_HEAD_BRANCH_NAME}"
          if [ $? -ne 0 ]; then
            echo "Error: Failed to checkout back to branch ${PR_HEAD_BRANCH_NAME}."
            exit 1
          fi
          git stash pop || true # Apply stashed changes back to the head branch, ignore errors if nothing stashed

          echo "Creating PR from '${PR_HEAD_BRANCH_NAME}' to '${PR_BASE_BRANCH_NAME}'"
          # 'gh pr create' will create a PR; '|| :' prevents the step from failing if PR already exists
          gh pr create \
            --base "${PR_BASE_BRANCH_NAME}" \
            --head "${PR_HEAD_BRANCH_NAME}" \
            --title "Releasing ${PR_HEAD_BRANCH_NAME} into ${PR_BASE_BRANCH_NAME}" \
            --fill || :
